#  TCP/IP协议

概念：即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。是指能够在多个不同网络间实现信息传输的协议簇（包括TCP、UDP、IP、HTTP等）。



##  网络模型

OSI模型层

| 层号 |   OSI层    |            描述            |     协议示例     |
| :--: | :--------: | :------------------------: | :--------------: |
|  7   |   应用层   |          应用数据          | HTTP、SMTP、IMAP |
|  6   |   表示层   |    数据表示、转换和加密    |     SSL/TLS      |
|  5   |   会话层   |         多连接管理         |        -         |
|  4   |   传输层   |      包或流的可靠传输      |     TCP、UDP     |
|  3   |   网络层   | 网络节点间的路由与数据分发 |    IP、IPSec     |
|  2   | 数据链路层 | 可靠的本地数据连接（LAN）  |      以太网      |
|  1   |   物理层   |  直接物理数据连接（电缆）  |       CAT5       |

TCP/IP协议族体系结构

| 层号 |    名称    |                             描述                             | 协议示例 |
| :--: | :--------: | :----------------------------------------------------------: | :------: |
|  4   |   应用层   |             决定了向用户提供应用服务时通信的活动             |   HTTP   |
|  3   |   传输层   | 向用户提供可靠的端到端的服务,传输层通过封装向高层屏蔽了下层数据通信的细节 |   TCP    |
|  2   |   网络层   |              为数据在节点之间的传输创建逻辑链路              |    IP    |
|  1   | 数据链路层 |                在通信的实体间建立数据链路连接                |  以太网  |

###  应用层

####  TeInet

常用于服务器远程控制，它使用虚拟终端机的形式，提供以字符串命令为主的双向交互功能。由于传统的Telnet会话数据没有加密，目前很多服务器都改用更安全的SSH

####  FTP

文件传输协议（File Transfer Protocol），是一个8位的客户端-服务器协议，FTP的缺点是有极高的延时。FTP服务一般运行在20与21端口，20用于传输数据流，21用于传输控制流。

####  SMTP

简单邮件传输协议（Simple Mail Transfer Protocol），指定一个消息的接收者（被确认存在），传输消息文本。使用的TCP端口为25。

####  HTTP

超文本传输协议（HyperText Transfer Protocol），基于TCP/IP通信协议传递数据，用于从万维网服务器传输超文本到本地浏览器的传送协议。

HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。

特点：

- 无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，立即断开连接，以便节省时间
- 媒体独立：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送
- HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。
- 无状态：无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快

####  DNS

域名系统（Domain Name System），一个提供域名和IP地址相互映射的数据库。

#####  前置知识

######  域名

域名，又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于定位。

管理方法：分不同的组来负责各子系统子系统/4670893)的名字。系统中的每一层叫做一个域，每个域用一个点分开。要求：

- 域名一般不能超过5级，从左到右域的级别变高，高的级域包含低的级域。
- 域名唯一，当高级子域名相同时，低级子域名不允许重复。
- 一台服务器只能有一个IP地址，但是却可以有多个域名。
- **有多少个点就为多少级域名，高级域名包含低级域名。**

######  根服务器

13组根服务器，每组服务器又由很多台服务器，负责整个域名的翻译工作。**相当于保存顶级域名的数据库地址**。

##### 域名解析全过程

1. 浏览器先检查自身缓存中有没有被解析过的这个域名的地址，如果有则结束；
2. 如果浏览器缓存中不存在（没有命中），则会在操作系统缓存中检查是否有对应的已解析的结果（host文件中设置/**DNS劫持**/）；
3. 如果还未命中，则请求本地域名服务器（LDNS，相对概念，指离用户较近的DNS服务器）来解析此域名，此台服务器性能较好且会缓存（高速缓存）大量域名解析结果；
4. 若LDNS仍未命中，则跳到**Root Server域名服务器**请求解析；
5. 根域名服务器**返回**给**LDNS**一个所查询域的顶级（主）域名服务器地址（.com、.cn、.org等）；
6. LDNS在发送请求到上一步返回的顶级域名服务器；
7. 接受请求的顶级域名服务器查找并返回这个域名对应的Name Server(一级域名的情况下，多级则循环5~7步)的地址，此时Name Server则为网站注册的域名服务器；
8. Name Server根据映射关系找到目标ip，返回给LDNS；
9. LDNS会在高速缓存中保存这个映射关系（有时限）；
10. LDNS把此解析结果返回给用户，用户再将其缓存至本地系统中，并结束。



DNS查询的两种方法（以DNS客户端和谁通信为判断依据）：

（1）递归：DNS客户端常用一般是递归服务器

![img](https://upload-images.jianshu.io/upload_images/1446087-729b159e25523fe9.png?imageMogr2/auto-orient/strip|imageView2/2/w/799/format/webp)

（2）迭代：DNS服务器间通常采用迭代查询方式

![img](https://upload-images.jianshu.io/upload_images/1446087-c15f2ecb770d0ff0.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

###  传输层

####  TCP

传输控制协议（Transmiss Control Protocol），一种基于字节流的传输层通信协议。

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层（IP层提供不可靠的包交换）。

TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。

接收端实体会对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。

TCP比UDP多的功能：**TCP**，控制传输协议，和UDP的差别很大，它充分实现了数据传输时的各种控制功能： 

· 有对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的慢启动算法和拥塞控制。

· 有对发送端发出的数据包的确认应答信号ACK；

· 有对数据包丢失或者出现定时器超时的重发机制；

· 有对数据包到达接收端主机顺序乱掉的顺序控制；

· 有对高效传输数据包的滑动窗口控制； 

· 有对避免网络拥堵时候的流量控制； 

TCP 协议如何保证可靠传输？

- 应用数据被分割成 TCP 认为最适合发送的数据块。
- TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
- **校验和**：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- TCP的接收端会丢弃重复的数据。
- **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）
- **拥塞控制**：当网络拥塞时，减少数据的发送。TCP的拥塞控制采用了四种算法，即 **慢开始 、 拥塞避免 、快重传 和 快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。
- **停止等待协议**: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；出现差错情况，超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。















####  UDP

用户数据报协议（User Datagram Protocol），是不可靠的数据报协议，因为UDP不需要应答，所以它的来源端口可选。由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错和复制粘贴

####  对比

|          |                   TCP                    |              UDP               |
| :------: | :--------------------------------------: | :----------------------------: |
| 面向对象 |                  字节流                  |              报文              |
| 是否连接 |               需要建立连接               |             无连接             |
| 是否可靠 | 可靠（无差错、不丢失、不重复，按序到达） |      不可靠（丢包、出错）      |
| 传输形式 |                  点对点                  | 一对一、一对多、多对一、多对多 |
| 首部开销 |                  20字节                  |             8字节              |





###  网络层

####  IP

网络协议（Internet Protocol），IP用于分组交换数据，IP的第一个架构是IPv4，它仍然是最主要的互联网协议，尽管目前世界各地正在积极部署IPv6。

（1）IP封装

数据在IP协议中传送中，被封装为数据报文（数据包=头（控制信息）+负载（信息数据）），IP协议是一种“尽最大努力交付”的数据包传输机制。

将IP地址解析为相应的数据链路地址的方法：IPv4（地址解析协议ARP）、IPv6（邻居发现协议NDP）

（2）可靠性

互联网协议提供的唯一帮助是，IPv4规定通过在路由节点计算校验和来确保IP数据报头是正确的。这个带来的副作用是当场丢弃报头错误的数据报文。在这种情况下不需要发送通知给任一个终端节点，但是互联网控制消息协议（ICMP）中存在一个机制来做到这一点。

但是，IPv6为了快速传输已经放弃了计算校验和的使用。

对这些可靠性问题的更正是一个上层协议的责任。（TCP）

####  ICMP

互联网控制消息协议，常用于TCP/IP网络中发送控制消息，ICMP是IP的主要部分，ICMP属于不可靠协议。

####  ARP

地址解析协议（Address Resolution），ARP 通过 解析网路层地址 来寻找 数据链路层地址 ，即通过网络地址(例：IPv4)来定位MAC地址。

在以太网中使用IP协议时，因为在以太网与上层IP协议中，只含有IP地址信息，所以需要ARP协议根据主机的IP地址找到其MAC地址，这就是地址解析。

####  RARP

逆地址解析协议，用于将MAC地址转换为IP地址





![img](https://upload-images.jianshu.io/upload_images/8141643-ae2a8aa4fdcf49b6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1059/format/webp)



##  介绍

超文本传输协议（英文：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

HTTP是一个客户端终端(用户)和服务器端(网站)请求和应答的标准(TCP),也就是,用于客户端和服务器端之间的通信。

##  工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

1. 客户端连接到Web服务器：HTTP客户端与web服务器的HTTP端口建立一个TCP连接（TCP connection）。（三次握手）
2. 发送HTTP**请求**：客户端向服务器发送一个文本的请求报文（请求行、请求头部、空行、请求数据）。
3. 服务器接受请求并返回HTTP**响应**：Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。（状态行、响应头部、空行、响应数据）
4. 释放TCP连接：若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。（四次挥手）
5. 客户端浏览器解析HTML内容：客户端先解析状态行，确定是否成功。然后解析每一个响应头，再读取响应数据，格式化后显示。

####  举例

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1. 浏览器向**DNS**服务器请求解析该 URL 中的域名所对应的**IP**地址;
2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 释放 TCP连接;
6. 浏览器将该 html 文本并显示内容。

####  三次握手

![img](https://upload-images.jianshu.io/upload_images/8141643-ef28dc9237f9a1f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/812/format/webp)

**目的**：三次握手的目的是为了确保客户端和服务器端连接正常，数据可以到达目标。

**注意**：两次握手是最基本的，第一次握手成功服务器端知道其可以和客户端成功连接；第二次握手成功后，客户端知道自己和服务端成功连接。**第三次**握手是为了避免死锁必不可少的策略（请求延迟的情况，服务端会一直为这个连接维持着资源，造成资源的浪费）。

####  四次挥手

![img](https://upload-images.jianshu.io/upload_images/3971776-9550b64ff16dbb0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/568/format/webp)

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

**目的**：确保数据能够完整传输。

**流程**：

第一次挥手：主动方发送一个**FIN（结束）**，通知被动方（进入**FIN_WAIT_1**状态）；

第二次挥手：被动方接收到传递过来的FIN后，返回一个**ACK（确认）**。此时主动方向被动方传输数据的通道关闭，（主动方此时还能接收数据）这时处于半关闭状态（进入**FIN_WAIT_2**状态，继续等待FIN报文）；

第三次挥手：被动方发送一个**FIN（结束）**到主动方，被动方关闭向主动方传输数据的通道（进入**LAST_ACK**状态，被动方不再传递数据）；

第四次挥手：主动方发送**ACK（确认）**确认（进入**TIME_WAIT**状态，若被动方没收到可重传；如果主动方等待了**2MSL**后没收到回复，则证明被动方已正常关闭），关闭TCP连接。

**注意**：

**为什么客户端最后还要等待2MSL？**

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个**ACK报文可能丢失**，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个**重传**的报文，接着给出回应报文，并且会**重启**2MSL计时器。

第二，防止类似与“三次握手”中提到了的“**已经失效的连接请求报文段**”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。





WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。



#  HTTP与HTTPS

##  HTTP

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

发展历史

|   版本   | 产生时间 |                             内容                             |      发展现状      |
| :------: | :------: | :----------------------------------------------------------: | :----------------: |
| HTTP/0.9 |   1991   | 不涉及数据包传输，规定客户端和服务器之间通信格式只有GET请求  |   未成为正式标准   |
| HTTP/1.0 |   1996   |        传输内容格式不限制，增加PUT、PATCH、HEAD等命令        |    正式作为标准    |
| HTTP/1.1 |   1997   | 持久连接（长连接 ）、节约带宽、HOST域、管道机制、分块传输编码 | 2015年前使用最广泛 |
| HTTP/2.0 |   2015   |        多路复用、服务器推送、头信息压缩、二进制协议等        |    逐渐覆盖市场    |

![这里写图片描述](https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。



##  HTTPS

HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

在数据进行传输之前，对数据进行加密，然后再发送到服务器。

##  对比

安全：主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

表现形式：HTTPS站点会在地址栏上显示一把绿色小锁。

SEO（搜索引擎优化）：HTTPS页面权重比HTTP页面更高。

技术层面：如果要说HTTPS和HTTP的区别，最关键的还是在技术层面。比如HTTP标准端口是80，而HTTPS标准端口是443；HTTP无需证书，HTTPS需要CA机构颁发的SSL证书；HTTP工作于应用层，HTTPS工作于传输层。





#  TCP

**概念**：传输控制协议（Transmiss Control Protocol），一种**可靠**的**面向连接**的基于**字节流**的传输层通信协议。

**对比**：与UDP相比，TCP会对数据传输进行各种控制（重发控制、顺序控制等），而UDP对数据传输不进行复杂控制，将部分控制转移给应用程序去处理。

##  特点

在数据传输过程中，可能会发生数据被破坏、丢包、重复发送以及分片顺序混乱等问题，为了实现数据的可靠传输，便需要使用一系列手段来解决这些问题。

TCP通过检验和、序列号、确认应答、重发控制、连接管理、窗口控制、流量控制以及拥塞阻塞等机制实现可靠性传输。

###  1、确认应答

在TCP中，当**发送端**的数据到达接收主机时，接收端会**返回一个已收到消息**的通知，这个通知叫作**确认应答**（ACK）

**<font color="red">意思就是说：为了保证可靠性，发送端没法送一个数据，就必须收到一个接收端发送的确认信号</font>**

####  流程

当发送端将数据发出之后会等待对端的确认应答(ACK)。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。若在一定时间内没有收到确认应答，发送端就可以认为数据已经丢失，并会重发数据。

<img src="C:\Users\obitesla\AppData\Roaming\Typora\typora-user-images\image-20200720191621981.png" alt="image-20200720191621981" style="zoom:80%;" />



若在一定时间内没有收到确认应答，发送端就可以认为数据已经丢失，并会重发数据。

<img src="C:\Users\obitesla\AppData\Roaming\Typora\typora-user-images\image-20200720192716183.png" alt="需要重发的情况" style="zoom: 80%;" />

####  重发超时

概念：重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。

计算：重发超时>报文往返时间+偏差（每次发包时都会计算）

若数据重发后还收不到确认应答，则会再次发送。此时，等待确认时间将会以2倍、4倍的指数函数增长。但数据也不会无限次的重发，达到一定次数仍未接收到确认应答时会强制关闭连接。

###  2、序列号

序列号是按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，并将自己下一步应该接收的序号作为确认应答返送回去。

确认应答处理、重发控制以及重复控制等功能都依靠序列号实现

###  3、连接管理

TCP面向连接指的是在数据通信开始之前先做好通信两端的准备工作

####  三次握手

建立连接使用三次握手的方式

第一次：SYN（请求建立连接）

第二次：ACK+SYN

第三次：ACK

#####  MSS

在三次握手的同时，也会确定发送数据包的单位，即最长消息长度（MSS）。两端的主机在发出建立连接的请求时，会在TCP首部写入MSS选项，告诉对方自己的接口适应的MSS大小

####  四次挥手

断开连接使用四次挥手的方式

第一次：FIN（请求切断链接）

第二次：ACK

第三次：FIN

第四次：ACK

最初发起断开请求的一方为什么要在最后一步等待2MSL（2*报文最大生存时间）/即第四步发送ACK应答信号后为什么要等待？

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个**ACK报文可能丢失**，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个**重传**的报文，接着给出回应报文，并且会**重启**2MSL计时器。

第二，防止类似与“三次握手”中提到了的“**已经失效的连接请求报文段**”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

###  4、窗口控制

基础TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样的话，包的往返时间越长，通信性能越低。

为了解决这个问题，TCP引入了窗口这个概念。

**窗口就是批量发送数据而无需等待应答的方式。**

窗口大小指的是无需等待应答就可以继续发送数据的最大值

假设窗口大小为4000字节

发送最开始四个段的时候无需等待ACK，直接发送，收到第一个ACK确认应答后，窗口向后移动，继续发送剩下数据

为了保证所有数据都正常到达，会开辟发送缓冲区记录当前还未应答的数据，只有ACK确认应答过的数据才能从缓冲区删掉

<img src="https://img-blog.csdn.net/20180620002804100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:80%;" />

####  丢包重传

丢包可以分为两种情况：

1. 数据包已收到，确认应答丢失

   这次情况下，丢包不会造成重传，因为可以通过后续的ACK确认对方收到了哪些数据包

   <img src="https://img-blog.csdn.net/20180620002838988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%;" />

2. 数据包丢失

   当某一段报文丢失，接收端会收到“需要XX”的确认响应，若发送端连续接收到三次同样的ACK确认应答，就说明此数据未到达接收端，此时会从发送端的缓冲区中发送所需数据

   <img src="https://img-blog.csdn.net/20180620002838988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%;" />

这种机制被称为“高速重发控制”（“快重传”）

###  5、流量控制

为了防止接收端在高负荷情况下将本应接收的数据丢弃的情况发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，即**流量控制**。

####  具体操作

接收端主机向发送端主机通知自己可以接受数据的大小，于是发送端就不会发送超过这个限度的数据。这个限度就是窗口大小。在TCP首部中用Window Size来通知窗口大小，接收主机会将自己可以接收的缓冲区大小放入这个字段中通知给发送端，发送端接收后就不允许发送超过此大小的数据。若值为0，则表示可以发送窗口探测，以获取最新的窗口大小。

<img src="https://img-blog.csdn.net/20180620002859330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%;" />

###  6、拥塞控制

有了TCP的窗口控制就可以高效可靠的发送大量数据，但在通信刚开始就发送大量数据可能导致其他问题的产生，比如网络拥堵或网络瘫痪。于是TCP就有了拥塞控制机制

**拥塞控制**：当网络拥塞时，减少数据的发送。TCP的拥塞控制采用了四种算法，即 **慢启动 、 拥塞避免 、快重传 和 快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

慢启动是指，在开始发送数据时，先发送少量数据，摸清当前网络拥堵状态后再决定按照多大的速度传输数据。

慢启动” 只是指初使时慢, 但是增长速度非常快.
为了不增长得那么快, 此处引入一个名词叫做`慢启动的阈值`, 当拥塞窗口的大小超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长.

拥塞窗口：

- 发送开始时，定义拥塞窗口大小为1
- 每次收到一个ACK应答，拥塞窗口加1
- 每次发送数据报的时候，将拥塞窗口和接收端主机反馈的窗口大小作比较，取较小的值作为实际发送的窗口。

<img src="https://img-blog.csdn.net/20180620002933354?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:80%;" />

- 当TCP开始启动时，慢启动阈值等于窗口最大值
- 在每次超时重发时，慢启动阈值会变成原来的一半，同时拥塞窗口置回1

少量的丢包, 我们仅仅是触发超时重传;
大量的丢包, 我们就认为是网络拥塞;
当TCP通信开始后, 网络吞吐量会逐渐上升;
随着网络发生拥堵, 吞吐量会立刻下降.

###  7、延迟应答

在每次接收数据后并不马上发送带有窗口大小（缓冲区所剩大小）的应答响应

限制：

- 数量限制：每隔N个包就应答一次
- 时间限制：超过最大延迟时间就应答一次

###  8、捎带应答

<img src="https://img-blog.csdn.net/20180620002955990?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%;" />



#  CDN

CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的**边缘服务器（Cache服务器）**，通过分布式存储、负载均衡、网络请求重定向和内容管理，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

##  作用

- **加速网站的访问**
- 减少带宽需求量
- 解决用户访问量大造成的服务器过载问题
- 降低网站自身建设和维护成本
- 提高网络访问的稳定性
- 实现跨运营商、跨地域的全网覆盖
- 保障网络安全
- 异地备援

##  特点

- 分布式存储
- 通过智能DNS解析或HTTP重定向实现内容分发的负载均衡
- 全局负载均衡管理与内容管理

##  原理

CDN网络就是在传统的Browser-Server（浏览器-服务器、B/S）架构中间增加Cache层（节点、服务器）。CDN将源站内容分发至这些边缘站点，当用户请求数据时，通过负载均衡将用户请求重定向至最适合缓存(Cache)服务器上获取内容。流程为：

###  流程

1. 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器（server-isp-DNS服务器）
2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户
3. 用户向CDN的全局负载均衡设备发起内容URL访问请求
4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求
5. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据**用户IP地址**，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的**内容名称**，判断哪一台服务器上有用户所需内容；查询各个服务器当前的**负载情况**，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台**缓存服务器的IP地址**
6. 全局负载均衡设备把服务器的IP地址返回给用户
7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的**上一级缓存服务器**请求内容，直至追溯到网站的**源服务器**将内容拉到本地

![img](https://images2015.cnblogs.com/blog/464291/201707/464291-20170703110938581-487079178.png)

![preview](https://pic2.zhimg.com/v2-0b5ceb1a269c38decf198a6df6496d43_r.jpg?source=1940ef5c)

**CDN基础架构图**

![img](https://pic3.zhimg.com/80/v2-b41cf4ec53559c2fb15010932ccb4e41_720w.jpg?source=1940ef5c)



##  注意

**1.CDN加速是对网站所在服务器加速，还是对其域名加速？**
CDN是只对网站的某一个具体的域名加速。如果同一个网站有多个域名，则访客访问加入CDN的域名获得加速效果，访问未加入CDN的域名，或者直接访问IP地址，则无法获得CDN效果。

**2.CDN和镜像站点比较有何优势？** 
CDN对网站的访客完全透明，不需要访客手动选择要访问的镜像站点，保证了网站对访客的友好性。CDN对每个节点都有可用性检查，不合格的节点会第一时间剔出，从而保证了极高的可用率，而镜像站点无法实现这一点。CDN部署简单，对原站基本不做任何改动即可生效。

**3.CDN和双线机房相比有何优势？** 
常见的双线机房只能解决网通和电信互相访问慢的问题，其它ISP（譬如教育网，移动网，铁通）互通的问题还是没得到解决。而CDN是访问者就近取数据，而CDN的节点遍布各ISP，从而保证了网站到任意ISP的访问速度。另外CDN因为其流量分流到各节点的原理，天然获得抵抗网络攻击的能力。

##  缺陷

由于CDN采用各节点缓存的机制，网站的静态网页和图片修改后，如果CDN缓存没有做相应更新，则看到的还是旧的网页。为了解决这个问题，CDN管理面板中提供了**URL推送服务**，来**通知CDN各节点刷新自己的缓存**。在URL推送地址栏中，输入具体的网址或者图片地址，则各节点中的缓存内容即被统一删除，并且当即生效。

##  适用场景

- 静态网页（资讯网站、政府机构网站、行业平台网站、商城）

  缓存一系列静态资源，html、css、js、img等

- 大文件下载

  软件下载、视频点播或图片存储

- 动态加速（实现困难）

  直播网站

  **（相当于设置缓存时间为0秒）**部分有实力也就是指有大量带宽的运营商开始采用带宽加速的方式实现动态的CDN加速。这个原理是怎么样的呢？简单来说就类似用镜像服务器给访问者做了一个高速的代理服务器，用过代理服务器的朋友应该知道，假如XX用户通过代理访问A站点的某个动态页面，那么代理服务器会先自己去访问A站点的这个动态页面，然后把A站点返回的内容再转发给XX用户，这样不管A站点的数据如何更新，XX用户每次访问那个动态页面都会从代理服务器得到最新的内容，当然，条件就是代理服务器连接A站点的速度跟连接用户的速度都非常快，这样才会有加速的效果，所以需要代理服务器有非常好的带宽，这样的话，一般的服务商是做不来的，所以大家知道为什么很多CDN服务商对动态内容的加速效果不好了吧，其实就是实力有限，带宽不足。

- 应用加速

  手机APP

###  不适用

![img](https://pic1.zhimg.com/80/v2-3cb264b4b37a79bdcd27afcbdf34b0e8_720w.jpg?source=1940ef5c)



##  CDN缓存

**与浏览器缓存类似（Cache-control）**

CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过**http响应头中的Cache-control: max-age**的字段来设置CDN边缘节点数据缓存时间。

**当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。**

CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。

CDN缓存时间会对“回源率”产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。







#  GET  POST

GET与POST是HTTP请求的两种基本方法。

##  区别

|                        |                   GET                   |                POST                |
| :--------------------: | :-------------------------------------: | :--------------------------------: |
|          功能          | 从服务器上获取数据（页面、图片、css等） |    向服务器传送数据（提交表单）    |
|      数据传输方式      |          添加进URL中，用户可见          | 添加进HTTP请求的body中，用户不可见 |
|   服务端获取值的方式   |           Request.QueryString           |            Request.Form            |
|          容量          |                   小                    |                 大                 |
|         安全性         |                   低                    |                 高                 |
|    浏览器回退有害性    |                  无害                   |        有害，会再次提交请求        |
|     能否被Bookmark     |                  可以                   |               不可以               |
|      浏览器cache       |                   会                    |          不会，需手动设置          |
|        编码方式        |                   url                   |                多种                |
| 参数在浏览记录中的情况 |                 被保存                  |             不会被保留             |

##  共同点

GET和POST都是TCP链接，本质上是一样的。只是因为HTTP的规定和浏览器/服务器的限制，才会在实际应用中体现出不同。



#  跨域

**跨域**：

- 广义：指一个域下的文档或脚本试图去请求另一个域下的资源
- 狭义：指由浏览器同源策略限制的一类请求场景



##  前置知识

###  同源

如果两个页面的协议、端口和域名都相同，则两个页面具有相同的源，即**同源**

###  同源策略

####  概念

**同源策略**是一种约定，它是**浏览器**最核心最基本的安全功能，缺少此策略会影响浏览器的正常功能。

####  作用

同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互。用于隔离潜在恶意文件的重要安全机制。

####  限制行为

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去

##  跨域方法

### JSONP

####  产生原因

因为同源策略的限制，Ajax等请求普通文件无法跨域，但是对于在Web上调用js文件不受跨域的影响（有src属性的标签都是）。那么将数据放入js文件就可以实现跨域。并且js有一种原生支持的纯字符数据格式——**JSON**。因此，web客户端通过调用脚本的方式，来调用跨域服务器上自动生成（目的在于把客户端需要的数据装进去）的js格式文件，以便获得需要的数据。为了便于客户端使用数据，逐渐形成一种非正式传输协议——JSONP，该协议的一个要点就是允许用户传递一个**callback参数**给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来**自动处理返回数据**了。

####  具体实现

jQuery实现

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
     <title>Untitled Page</title>
      <script type="text/javascript" src=jquery.min.js"></script>
      <script type="text/javascript">
     jQuery(document).ready(function(){ 
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 /*
                                                                               ******跨域成功后调用的回调函数         
                                                                             */
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
</html>

```

补充：形式上和Ajax很像，但本质上是不同的。Ajax的核心是通过XmlHttpRequest获取非本页内容，而JSONP的核心是动态添加。

**注意**：JSONP请求只能是GET<font color=red>（为什么）</font>



###  跨域资源共享CORS

CORS是一个W3C标准，全称为“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。

####  简介

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，实现CORS通信的关键是**服务器**。只要服务器实现了CORS接口，就可以跨源通信。

####  两种请求

浏览器将CORS请求分成两类：简单请求和非简单请求。因此，**浏览器对两种请求的处理是不一样的**。

#####  简单请求

------

简单请求必须满足两个条件：

1. 请求方法必须是**HEAD、GET、POST**三种之一
2. HTTP的头信息不超出以下几种字段：
   - Accept
   - Accept-Language
   - Content-Language
   - Last-Event-ID
   - Content-Type

------

对于简单请求，浏览器直接发出CORS请求。就是在头信息中增加一个**Origin**字段。这个字段用来说明，**本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，决定是否同意这次请求**。

######  指定源不在许可范围内（失败）

服务器会返回一个正常的HTTP回应。浏览器在这个回应的头信息中未发现**`Access-Control-Allow-Origin`**字段，则会认定此请求出错，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。

######  指定的源在许可范围内（成功）

此时服务器也会返回响应，会多出几个头信息字段，分别为：`Access-Control-Allow-Origin`、`Access-Control-Allow-Credentials`、`Access-Control-Expose-Headers`、`Content-Type`。

- `Access-Control-Allow-Origin`：必须有。值要么是请求**Origin**字段的值，要么是一个**`*`**（表示接受任意域名的请求）
- `Access-Control-Allow-Credentials`：可选。是一个**布尔值**，表示是否允许发送**Cookie**。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器（开发者必须在AJAX请求中打开`withCredentials`属性）。这个值也**只能**设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。
- `Access-Control-Expose-Headers`:可选。在此字段中指定预获取的字段，然后可以使用`getResponseHeader()`方法获取

#####  非简单请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

######  流程

1. 浏览器先发送预检请求给服务器；
2. 服务器接收到预检请求后判断是否允许跨源请求并返回相应的字段给浏览器。如果否定了也会返回一个正常的HTTP回应，此时会触发一个错误；
3. 如果允许跨域资源请求，浏览器发送正常的CORS请求并等待响应

######  预检请求

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为**"预检"请求**（preflight）。此时浏览器先询问服务器（**OPTIONS**方法），当前网页所在的**域名是否在服务器的许可名单中**，以及可以使用哪些**HTTP动词**和**头信息字段**。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

预检请求的请求方法是`OPTIONS`，表示这个请求是用来询问的。`Origin`表示请求来自哪个源。特殊字段：

1. `Access-Control-Request-Method`：必须，用来列出浏览器的CORS请求会用到哪些HTTP方法。
2. `Access-Control-Request-Method`：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

######  预检请求的回应

收到预检请求并确认允许跨域请求后，就可以做出回应。若否定了预检请求，会像简单请求一样返回个正常的HTTP回应并报错。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

特殊字段：

1. `Access-Control-Allow-Methods`：必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是**所有**支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求
2. `Access-Control-Allow-Headers`：如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
3. `Access-Control-Allow-Credentials`：与简单请求的含义一样。是一个**布尔值**，表示是否允许发送**Cookie**。
4. `Access-Control-Max-Age`：可选，用来指定本次预检请求的有效期，单位为秒。

剩下的就和简单请求一样发送CORS请求。

<font color=red>**注意**:JSONP只支持`GET`请求，CORS支持**所有**类型的HTTP请求。JSONP的优势在于支持**老式浏览器**，以及可以向**不支持CORS的网站**请求数据。</font>

###  document.domain+iframe跨域

**此方案仅限主域相同，子域不同的跨域应用场景**

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

###  location.hash+iframe跨域

实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。







#  RESTful

RESTful是一种网络应用程序的设计风格与开发的方式，基于HTTP，可以使用XML格式定义或JSON格式定义。

REST指的是一组架构约束条件和原则，只要满足这些约束条件和原则的应用程序或设计就是RESTful。

特点：

1. 每个URI代表1种资源；
2. 客户端使用GET、POST、PUT、DELETE 4个操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新），PUT用来更新资源，DELETE用来删除资源；
3. 通过操作资源的表现形式来操作资源；
4. 资源的表现形式是XML或HTML；
5. 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求必须包含理解请求所必须的信息。

**RESTful架构是对MVC架构改进后所形成的一种架构**，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。

RESTful架构将[服务器](https://baike.baidu.com/item/服务器/100571)分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。

项目开发引入RESTful架构，利于团队并行开发。在RESTful架构中，将多数HTTP请求转移到前端服务器上，降低服务器的负荷，使视图获取后端模型失败也能呈现。但RESTful架构却不适用于所有的项目，当项目比较小时无需使用RESTful架构，项目变得更加复杂。





#  cookie

##  基础知识

###  定义

cookie是一个保存在客户端的简单文本文件，伴随着用户**请求**和**页面**在Web服务器和浏览器之间传递。cookie包含每次用户访问站点时的Web应用程序都可以读取的信息。

###  存在意义

为了使网络请求更快速，HTTP被设定为**无状态协议**，这次请求和上一次请求就没有任何关系，于是就实现了请求的快速发送。但在实际运用中，存在某些网络需要**保存某些或共用某些信息**的情况。于是cookie便应运而生，用来帮助网站存储有关访问者的信息。一般来说cookie是一种保持web应用程序连续性的方法。

###  组成

cookie是一段不超过4KB的小型文本数据，由一个"Name-Value"键值对和Expires属性、Path属性、Domain属性、Secure属性、HTTPOnly等可选属性组成，用以控制其有效期、安全性、适用范围。

- Name/Value：设置cookie的名称及相对应的值
- Expires属性：设置cookie的生存期。cookie分为两种：会话性和持久性。若cookie中**没有Expires属性**，此为**会话性cookie**，进保存在**浏览器内存**中，**浏览器关闭时失效**；反之为持久性cookie，会保存在**用户硬盘**中，直至生存期到期或用户“注销”
- Path属性：定义了Web站点上可以访问此cookie的目录
- Domain属性：指定了可以访问此cookie的web站点或域。允许子域设置或获取其父域的cookie。为了降低cookie受攻击的风险，要求Domain属性不能设置为顶级域名和二级域名。
- Secure属性：指定是否使用[HTTPS](https://baike.baidu.com/item/HTTPS/285356)安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的[SSL](https://baike.baidu.com/item/SSL/320778)证书的有效性
- HTTPOnly属性：用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头

##  工作流程

1. 发布cookie

   当用户视图试图访问某web站点中需要认证的资源时，web服务器会检查用户是否提供了认证cookie。若没有，则将用户重定向到登陆界面。用户登录成功后，由web服务器产生认证cookie，并通过HTTP响应的Set-Cookie头发送给客户端，用于对用户随后的请求进行检查和验证，接着将用户重定向到初始请求的资源

2. 检索cookie

   在用户随后的访问中，客户端浏览器检索Path与Domain等属性与用户请求资源相匹配的cookie，并将找到的cookie通过HTTP请求中的cookie提交给Web服务器

3. 验证cookie

   web服务器提取客户端浏览器递交的cookie，验证其中的访问令牌。若合法，则将访问请求的资源发送给客户端浏览器，反之则拒绝访问

##  高级知识

###  内存限制

大多数浏览器支持最大为4096字节的cookie。

大多数浏览器只允许每个站点存储20个cookie（指主键值，也就是20条cookie记录，但每个cookie记录还可包含若干子建）。

有些浏览器会限制接受所有站点的cookie总数为300个

###  过期时间

如果保存Cookies时未设置过期时间， 则Cookies的过期时间为“当前浏览器进程有效”，即和Session一样关闭浏览器后则消失。

如果设置了过期时间并且大于当前时间，则会保存Cookies值。

如果设置了过期时间但是小于等于当前时间，则清除Cookies值。









#  cookie  session

##  前言

HTTP是无状态协议，就是指这一次请求和上一次请求没有任何关系，没有关联，这样的好处是**快速**。但有时我们又需要某个域名下的所有网站能够共享某些数据（**一个用户的所有请求操作都应该属于同一个会话**），于是**cookie**和**session**就出现了。

流程：

- 客户端发送一个HTTP请求到服务端
- 服务端接收到客户端请求后，建立一个session，并发送一个HTTP响应到客户端，这个响应头，其中包含了**Set-Cookie**头部。该头部包含了SessionID，会在客户端设置一个属于这个域名下的cookie
- 在客户端发起第二次请求时，浏览器会自动在请求头中添加cookie（包括SessionID）
- 服务器接收请求，分解cookie，验证信息，核对成功后返回响应给客户端

##  cookie

###  定义

类型为“**小型文本文件**”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据，由用户客户端计算机暂时或永久保存的信息。

###  特点/性质

####  具有保质期

Cookie有永久的也有临时的，Cookie中的maxAge决定其有效期，单位为秒。

- maxAge为正数时，则表示Cookie会在maxAge秒后自动失效。这种情况下，浏览器会将Cookie写到对应的Cookie文件中。无论关闭浏览器还是电脑，只有时间到了此Cookie才会失效。
- maxAge为负数时（默认值为-1），则表示此Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口即失效。这类Cookie为临时性，Cookie信息保存在浏览器内存中。
- maxAge为0，则表示删除该Cookie。

####  满足同源策略

Cookie不可跨域名，这由Cookie的隐私安全机制决定，禁止网站非法获取其他网站的Cookie。正常情况下，同一个一级域名下的两个二级域名不能交互使用Cookie。

####  内存大小受限

Cookie有个数和大小的限制，大小一般为4k。

![clipboard.png](https://segmentfault.com/img/bVbgk5m?w=910&h=207)

####  安全性不足

Cookie文件可以在本地被更改，所以不应该把敏感数据放在Cookie中，并且要注意加密。

####  不能直接修改、删除

- 修改：只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。
- 删除：只需要新建一个同名的Cookie，并将生存期设置为0，并添加到response中覆盖原来的Cookie。



##  Session

###  定义

Session（会话）是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器时，服务器把客户端信息以某种形式记录在服务器上，当客户端浏览器再次访问时只需要从该Session中查找该客户的状态即可。

###  实现

- 首先，服务器开辟Session存储空间并创建Session，服务器会为该Session生成唯一的SessionID并添加相应内容
- 服务器将SessionID发送给客户端，客户端将其保存
- 当客户端再次发送请求时会带上SessionID
- 服务器接收请求后根据SessionID找到相应的Session

###  特点/性质

####  具有生命周期

Session在用户第一次访问服务器时自动创建，生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。

####  具有有效期

Session有maxInactiveInterval属性，为超时时间。如果一个用户超过了超时时间没访问过服务器，Session就自动失效。

####  一般与Cookie共同使用（依赖关系）

Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。

##  Cookie与Session的关系

###  区别

- Cookie数据存放在客户的浏览器上，Session数据放在服务器上
- Cookie不是很安全，Session更加安全
- Session会在一定时间保存在服务器上。当访问增多，会占用服务器的性能。为减轻压力，可使用Cookie
- Cookie大小有限制



#  token

概念：Token是服务端生成的一串字符串，以作为客户端请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端并保存，以后客户端请求数据只需带上这个Token即可，无需再次带上用户名和密码。

##  流程

1. 客户端使用用户名和密码请求登录
2. 服务端收到请求，去验证用户名和密码
3. 验证成功后，服务端会签发一个Token，再把这个Token发送给客户端
4. 客户端收到Token以后将其保存，比如放在Cookie或Local Storage里
5. 客户端每次向服务端请求资源时带着服务端签发的Token
6. 服务端收到请求，然后去验证请求中的Token，如果验证成功就向客户端返回请求的数据，失败则返回错误信息，令其重新登陆

##  特点

- 无状态
- 安全性：请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)
- 可扩展：Tokens能够创建与其它程序共享权限的程序
- 多平台跨域

##  原理

![img](https://img2018.cnblogs.com/blog/1598504/201902/1598504-20190202220449263-1608141775.png)

1.将荷载payload，以及Header信息进行Base64加密，形成密文payload密文，header密文。

　　2.将形成的密文用句号链接起来，用服务端秘钥进行HS256加密，生成签名.

　　3.将前面的两个密文后面用句号链接签名形成最终的token返回给服务端

注：

　　（1）用户请求时携带此token(分为三部分，header密文，payload密文，签名)到服务端，服务端解析第一部分(header密文)，用Base64解密，可以知道用了什么算法进行签名，此处解析发现是HS256。

　　（2）服务端使用原来的秘钥与密文(header密文+"."+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。

　　（3）判断是否过期，客户端通过用Base64解密第二部分（payload密文），可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期。





#  cookie、localStorage与sessionStorage

##  概念

web Storage是HTML5引入的一个重要功能，提供了一种在cookie之外存储会话数据的方式与大量可以跨会话存在的数据机制。在前端开发的过程中会经常遇到，可以在客户端本地存储数据，类似cookie，但其功能却比cookie强大。cookie的容量只有4Kb左右，而web Storage的容量有5MB。

web Storage提供了两种API：localStorage(本地存储)和sessionStorage(会话存储)

|                  |                    localStorage                    |                      sessionStorage                      |
| :--------------: | :------------------------------------------------: | :------------------------------------------------------: |
|       定义       |                      本地存储                      |                         会话存储                         |
|      作用域      | 相同浏览器的不同页面之间可以共享相同的localStorage | 只能在相同浏览器的相同页面或标签下才能共享sessionStorage |
|     生命周期     |                        永久                        |                       会话结束清除                       |
|     存储大小     |                        5MB                         |                           5MB                            |
|     存储位置     |                       客户端                       |                          客户端                          |
| 是否与服务器通信 |                         否                         |                            否                            |
|   存储内容类型   |                     字符串类型                     |                        字符串类型                        |
|     获取方式     |                window.localStorage                 |                  window.sessionStorage                   |
|       应用       |                       草稿箱                       |                       保存身份信息                       |

操作方法：

- `setItem(key,value)`：保存数据，以键值对的方式储存信息
- `getItem(key)`：获取数据，将键值传入，即可获取到对应的value值
- `removeItem(key)`：删除单个数据，根据键值移除对应的信息
- `clear()`：删除所有数据
- `key(index)`：获取某个索引的key

##  项目中应用

存储用户权限值